kcos60 = Math.cos(Math.PI/3); // FIXME
ksin60 = Math.sin(Math.PI/3);

//
// Geometry of the MicroBooNE detector.
//
// Unless stated otherwise, all measurement in cm
//


function OpDetGeo ()
{
  // This code generated by geometry looter. Run geoloot.fcl, and copy geo_opdet.json here.
  this.opticalDetectors = [
  { opdet: 0 ,  x: -141.487 +128.0,    y:55.249  , z:108.693  , type: 'pmt'},

    
 ] ;
  
  this.opDetByChan = [];
  for(var i=0; i<this.opticalDetectors.length;i++) {
    // this.opticalDetectors[i].z-=30.;
    this.opDetByChan[this.opticalDetectors[i].opdet] = this.opticalDetectors[i];
  }
  this.paddle_wx = 1/8*2.54;
  this.paddle_wy = 20*2.54;
  this.paddle_wz = (7.3333)*3.54;
  this.pmtRadius = 15.2; // Size of the TPB Coating, according to the root geometry file.
  
  
  
  // function OpDetByChannel(chan){ return this.opDetByChan[chan]; } 
  
}

OpDetGeo.prototype.OpDetByChannel = function(chan)
{ return this.opDetByChan[chan%100]; };


OpDetGeo.prototype.pathYZ = function(ctx, type)
{ 
  // assumes call has set up ctx centered on this detector, and scaled to cm.
  // Traces the path; lets the caller do the fill or stroke.
  ctx.beginPath();
  if(type=='pmt') {
    ctx.arc(0,0,this.pmtRadius ,0,Math.PI*1.999,false);
  } else if(type=='paddle') {
    ctx.beginPath();
    ctx.moveTo(-this.paddle_wz/2,-this.paddle_wy/2);
    ctx.lineTo(-this.paddle_wz/2, this.paddle_wy/2);
    ctx.lineTo( this.paddle_wz/2, this.paddle_wy/2);
    ctx.lineTo( this.paddle_wz/2,-this.paddle_wy/2);    
    ctx.lineTo(-this.paddle_wz/2,-this.paddle_wy/2);
  }
};



/////////////////////////////////////////////////////////////////////////////


function Geometry()
{
  this.kU = [kcos60, -ksin60];
  this.kV = [kcos60,  ksin60];

  this.opDets = new OpDetGeo();

  this.temperature = 87; // Kelvin
  this.hv = 70; // kVolts total
  this.SetHV(
      180, // kVolts total,
      87      // lAr temperature, Kelvin
  ); // sets this.drift_cm_per_tick


  // X distance from origin of wire planes 0,1,2.
  this.wirePlaneX = [0,0.270,0.521];
  
  this.wirePitch = 3.33333; // wire per cm
}



Geometry.prototype.wireCrossing = function(geoWire1,geoWire2)
{
  var result;
  
  var ua_t = (geoWire2.z2 - geoWire2.z1) * (geoWire1.y1 - geoWire2.y1) - (geoWire2.y2 - geoWire2.y1) * (geoWire1.z1 - geoWire2.z1);
  var ub_t = (geoWire1.z2 - geoWire1.z1) * (geoWire1.y1 - geoWire2.y1) - (geoWire1.y2 - geoWire1.y1) * (geoWire1.z1 - geoWire2.z1);
  var u_b  = (geoWire2.y2 - geoWire2.y1) * (geoWire1.z2 - geoWire1.z1) - (geoWire2.z2 - geoWire2.z1) * (geoWire1.y2 - geoWire1.y1);

  if ( u_b !== 0 ) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      return { z: geoWire1.z1 + ua * (geoWire1.z2 - geoWire1.z1),
               y: geoWire1.y1 + ua * (geoWire1.y2 - geoWire1.y1) };
  } 
  
  return null; 
};

Geometry.prototype.viewOfPlane = function(plane)
{
  return plane;
};

Geometry.prototype.planeOfView = function(view)
{
  return view;
};


Geometry.prototype.channelOfWire = function(plane,wire)
{
  switch(plane) {
    case 0: return wire;
    case 1: return wire+800; 
    case 2: return wire+1600;
  }
};

Geometry.prototype.wireOfChannel = function(channel)
{
  if(channel < 800) return {plane: 0, wire: channel};
  else if(channel <1600) return { plane: 1, wire: channel-800};
  else return {plane:2, wire: channel-1600};
};


Geometry.prototype.numWires = function(plane)
{
  switch(plane) {
    case 0: return 800;
    case 1: return 800;
    case 2: return 960;
  }
  return 960;
};

// Code from Looter_module.cc, inside framework.


Geometry.prototype.getXofTDC = function(plane,tdc)
{
  return tdc*this.drift_cm_per_tick - this.wirePlaneX[plane];
};

Geometry.prototype.getTDCofX = function(plane,x)
{
  return (x + this.wirePlaneX[plane]) / this.drift_cm_per_tick;
};

// Code automagically generated by fitgeo.C 
  // Code automagically generated by fitgeo.C 
Geometry.prototype.getWire = function(plane,wire) 
{ 
  var r={};
  switch(plane) {
    case 0:
      r.cx = 0.000;
      if(wire<671) {
        r.section = 0;
        r.cy = 117.277+wire*(-0.173);
        r.cz = 0.350+wire*(0.500);
        r.y1 = 117.194+wire*(-0.346);
        r.y2 = 117.360;
        r.z1 = 0.206;
        r.z2 = 0.494+wire*(1.000);
        r.halfl = 0.166+wire*(0.346);
        r.thetaz = 0.524;
      } else if(wire<1727) {
        r.section = 1;
        r.cy = 0.970;
        r.cz = -201.100+wire*(1.000);
        r.y1 = -115.523;
        r.y2 = 117.463;
        r.z1 = -402.871+wire*(1.00);
        r.z2 = 0.671+wire*(1.00);
        r.halfl = 232.985;
        r.thetaz = 0.524;
      } else {
        r.section = 2;
        r.cy = 300.182+wire*(-0.173);
        r.cz = 317.150+wire*(0.500);
        r.y1 = -115.420;
        r.y2 = 715.784+wire*(-0.546);
        r.z1 = -402.694+wire*(0.600);
        r.z2 = 1036.994;
        r.halfl = 831.204+wire*(-0.546);
        r.thetaz = 0.524;
      }
    break; 
    case 1:
      r.cx = -0.300;
      if(wire<671) {
        r.section = 0;
        r.cy = -115.337+wire*(0.173);
        r.cz = 0.150+wire*(0.300);
        r.y1 = -115.420;
        r.y2 = -115.254+wire*(0.346);
        r.z1 = 0.294+wire*(0.600);
        r.z2 = 0.006;
        r.halfl = 0.166+wire*(0.346);
        r.thetaz = 2.618;
      } else if(wire<1727) {
        r.section = 1;
        r.cy = 0.970;
        r.cz = -201.300+wire*(0.600);
        r.y1 = -115.523;
        r.y2 = 117.463;
        r.z1 = 0.471+wire*(0.600);
        r.z2 = -403.071+wire*(0.600);
        r.halfl = 232.985;
        r.thetaz = 2.618;
      } else {
        r.section = 2;
        r.cy = -298.242+wire*(0.173);
        r.cz = 316.950+wire*(0.300);
        r.y1 = -713.844+wire*(0.346);
        r.y2 = 117.360;
        r.z1 = 1036.793;
        r.z2 = -402.893+wire*(0.600);
        r.halfl = 831.204+wire*(-0.346);
        r.thetaz = 2.618;
      }
    break; 
    case 2:
      r.cx = -0.600;
        r.section = 0;
        r.cy = 0.970;
        r.cz = 0.150+wire*(0.300);
        r.y1 = -115.530;
        r.y2 = 117.470;
        r.z1 = 0.150+wire*(0.300);
        r.z2 = r.z1;
        r.halfl = 116.500;
        r.thetaz = 1.571;
    break; 
  }
  return r;
};


  // Code automagically generated by fitgeo.C 
Geometry.prototype.yzToWire = function(plane,y,z)
{
 var trans, wire;
 switch(plane) {
   case 0:
      trans= this.kU[0]*z + this.kU[1]*y;
      wire = 337.50194+trans*(3.33332);
      break;
   case 1:
      trans= this.kV[0]*z + this.kV[1]*y;
      wire = 332.16920+trans*(3.33333);
      break;
   case 2:
      wire = -1.16434+z*(3.33333);
      break;
 }
  return wire;
};


Geometry.prototype.SetHV = function(hv, temperature) 
{
    // computes field and drift velocity in cm/us, given temperature and hv.

    // Link to util::LArProperties::DriftVelocity() (code in LArSoft, lardata/Utilities/LArProperties_service.cc):
    // http://nusoft.fnal.gov/larsoft/doxsvn/html/classutil_1_1LArProperties.html#ae7778dccb5e6f6e3bdc839734b1232f8
    // Drift Velocity as a function of Electric Field and LAr Temperature
    // from : W. Walkowiak, NIM A 449 (2000) 288-294
    // Efield should have units of kV/cm
    // Temperature should have units of Kelvin
    this.hv = hv || 70.0;
    this.temperature = temperature || 87.302; // Kelvin
    
    this.efield = this.hv /256.04; // 
    var efield = this.efield;    
    
    
    var tshift = -87.203+this.temperature;
    var xFit = 0.0938163-0.0052563*tshift-0.0001470*tshift*tshift;
    var uFit = 5.18406+0.01448*tshift-0.003497*tshift*tshift-0.000516*tshift*tshift*tshift;
    var vd;


    // Icarus Parameter Set, use as default
    var  P1 = -0.04640; // K^-1
    var  P2 = 0.01712;  // K^-1
    var  P3 = 1.88125;   // (kV/cm)^-1
    var  P4 =  0.99408;    // kV/cm
    var  P5 =  0.01172;   // (kV/cm)^-P6
    var  P6 =  4.20214;
    var  T0 =  105.749;  // K
        // Walkowiak Parameter Set
    var    P1W = -0.01481; // K^-1
    var  P2W = -0.0075;  // K^-1
    var   P3W =  0.141;   // (kV/cm)^-1
    var   P4W =  12.4;    // kV/cm
    var   P5W =  1.627;   // (kV/cm)^-P6
    var   P6W =  0.317;
    var   T0W =  90.371;  // K

    // From Craig Thorne . . . currently not documented
    // smooth transition from linear at small fields to 
    //     icarus fit at most fields to Walkowiak at very high fields
    if (efield < xFit) vd=efield*uFit;
    else if (efield<0.619) { 
     vd = ((P1*(this.temperature-T0)+1)
                 *(P3*efield*Math.log(1+P4/efield) + P5*Math.pow(efield,P6))
                 +P2*(this.temperature-T0));
    }
    else if (efield<0.699) {
     vd = 12.5*(efield-0.619)*((P1W*(this.temperature-T0W)+1)
               *(P3W*efield*Math.log(1+P4W/efield) + P5W*Math.pow(efield,P6W))
               +P2W*(this.temperature-T0W))+
       12.5*(0.699-efield)*((P1*(this.temperature-T0)+1)
               *(P3*efield*Math.log(1+P4/efield) + P5*Math.pow(efield,P6))
               +P2*(this.temperature-T0));
    }
    else {
     vd = ((P1W*(this.temperature-T0W)+1)
               *(P3W*efield*Math.log(1+P4W/efield) + P5W*Math.pow(efield,P6W))
               +P2W*(this.temperature-T0W));     
    }

    vd /= 10.; // vd is now in cm/us
    
    // Convert to standard units: cm per tick
    this.drift_cm_per_tick = vd/2.0;  // 2.0 Mhz per tick
    
    // (0.3 cm/wire) / (0.081 cm/tdc)
    this.fTdcWirePitch = 0.3/ this.drift_cm_per_tick; // tdc per wire.
    
};


gGeo = new Geometry();


